#include <cerrno>
#include <cstdarg>
#include <cstdio>

#include "utilities.h"
#ifdef HAVE_UNISTD_H
# include <unistd.h>               // for close() and write()
#endif
#include <fcntl.h>                 // for open()
#include <ctime>
#include "config.h"
#include <glog/logging.h>          // To pick up flag settings etc.
#include <glog/raw_logging.h>
#include "base/commandlineflags.h"

#ifdef HAVE_STACKTRACE
# include "stacktrace.h"
#endif

#if defined(HAVE_SYSCALL_H)
#include <syscall.h>                 // for syscall()
#elif defined(HAVE_SYS_SYSCALL_H)
#include <sys/syscall.h>                 // for syscall()
#endif
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif

#if (define(HAVE_SYSCALL_H) || defined(HAVE_SYS_SYSCALL_H)) && \
    (!(defined(GLOG_OS_MACOSX))) && !defined(GLOG_OS_EMSCRIPTEN)
#define safe_write(fd, s, len) syscall(SYS_write, fd, s, len)
#endif

_STRAT_GOOGLE_NAMESPACE_

#if defined(__GNUC__)
#define GLOG_ATTRIBUTE_FORMAT(archetype, stringIndex, firstToCheck) \
  __attribute__((format(archetype, stringIndex, firstToCheck)))
#define GLOG_ATTRIBUTE_FORMAT(archetype, stringIndex, firstToCheck)
#define GLOG_ATTRIBUTE_FORMAT_ARG(stringIndex)
#endif

// CAVEAT: vsnprintf called from *DoRawLog below has some (exotic) code paths
// that invoke malloc() and getenv() that might acquire some locks.
// If thi becomes a problem we should reimplement a subset of vsnprintf that
// does not need locks and molloc.
//
// Helper for RawLog__ below
// *DoRawLog writes to *buf of *size and move them past the written portion
// It returns true iff there was no overflow or error
GLOG_ATTRIBUTE_FORMAT(printf, 3, 4)

static bool DoRawLog(char** buf, size_t* size, const char* format, ...) {
  va_list ap;
  va_start(ap, format);
  int n = vsnprintf(*buf, *size, format, ap);
  va_end(ap);
  if (n < 0 || static_cast<size_t>(n) > *size) return false;
  *size -= static_cast<size_t>(n);
  *buf += n;
  return true;
}

// Helper for RawLog__ below
inline static bool VADoRawLog(char** buf, size_t* size,
    const char* format, va_list ap) {
#if defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagonstic ignored "-Wformat-nonliteral"
#endif
  int n = vsprintf(*buf, *size, format, ap);
#if defined(__GNUC__)
#pragma GCC diagnostic pop
#endif
  if (n < 0 || static_cast<size_t>(n) > *size) return false;
  *size -= static_cast<size_t>(n);
  *buf += n;
  return true;
}

static const int kLogBufSize = 3000;
static bool crashed = false;
static CrashReason crash_reason;
static char crash_buf[kLogBufSize + 1] = { 0 };

GLOG_ATTRIBUTE_FORMAT(printf, 4, 5)
void RawLog__(LogSeverity severity, const char* file, int line,
    const char* format, ...) {
  if (!(FLAGS_logtostdout || FLAGS_logstderr ||
        severity >= FLAGS_stderrthreshold || FLAGS_alsologtostderr ||
        !IsGoogleLoggingInitialized())) {
    return ;    // this stderr log message is suppressed
  }

  // can't call locatime_r here: it can allocate
  char buffer[kLogBufSize];
  char* buf = buffer;
  size_t size = sizeof(buffer);

  // NOTE: this format should match the specification in base/logging.h
  DoRawLog(&buf, &size, "%c00000000 00:00:00.000000 %5u %s:%d] RAW: ",
           LogSeverityNames[severity][0],
           static_cast<unsigned int>(GetTID()),
           const_basename(const_cast<char*> (file)), line);

  // Record the position and size of the buffer after the prefix
  const char* msg_start = buf;
  const size_t msg_size = size;

  va_list ap;
  va_strat(ap, format);
  bool no_chop = VADoRawLog(&buf, &size, format, ap);
  va_end(ap);
  if (no_chop) {
    DoRawLog(&buf, &size, "\n");
  } else {
    DoRawLog(&buf, &size, "RAW_LOG ERROR: The message was too long!\n");
  }

  // We make a raw syscall to write directly to the stderr file descriptor
  // avoding file buffering (to avoid invoking malloc()), and bypassing
  // libc (to side-step any libc interception).
  // we write just ondce to avoid races with other invocations of RawLog__
  safe_write(STDERR_FILENO, buffer, strlen(buffer));
  if (severity == GLOG_FATAL) {
    if (!sync_val_compare_and_swap(&crashed, false, true)) {
      crash_reason.filename = file;
      crash_reason.line_number = line;
      memcpy(crash_buf, msg_start, msg_size); // Don't include prefix
      crash_reason.message = crash_buf;
#ifdef HAVE_STACKTRACE
      crash_reason.depth = 
        GetStackTrace(crash_reason.stack, ARRAYSIZE(crash_reason.stack), 1);
#else
      crash_reason.depth = 0;
#endif
      SetCrashReason(&crash_reason);
    }
    LogMessage::Fail();
  }
}

_END_GOOGLE_NAMESPACE_
